"""
pdb2.py
by Lane Votapka
Amaro Lab 2015

This file contains multiple functions and classes that can be used to 
read and write PDB, PQR, and PQRXML formats in versatile ways. It also 
contains some functions for processing loaded structures, such as 
center-of-mass calculations, etc.

"""
import re
import warnings
import time
import os
import sys
from copy import deepcopy
import string
import numpy
from numpy import array, matrix
# NOTE: may want to change this to cStringIO if more speed is needed 
# in the future
from cStringIO import StringIO
#from modscience import normalize_vector # makes the longest vector 
# equal to 1 # this is too annoying to import
import unittest
import xml.etree.cElementTree as ET
# for parsing the XML
from xml.etree.cElementTree import iterparse
# allows files to be loaded as a special object
from cStringIO import StringIO 

# all the atomic weights. NOTE: 'G' refers to a "ghost" atom
REMARK = "REMARK   1 File generated by pdb2.py by Lane Votapka\n"
atomic_weights = {"H":1.00800, "C":12.0110, "N":14.00699, "O":15.9994, 
                  "F":18.9984, "Na":22.9898, "Mg":24.305, "P":30.9738, 
                  "S":32.065, "Cl":35.453, "K":39.0983, "Ca":40.078, 
                  "Fe":55.845, "Br":79.904, "I":126.9045, "":0.0, 
                  " ":0.0, "G":0.0} 
radii = {"C": 1.9080, "N":1.824, "H":0.0000, "O":1.66, "S":2.000, 
         "Ca":1.97, "P":2.00, "Cu":2.5, "Zn":2.5, "":0.0, "G":0.0}
# atom names after which automatically a"dd a TER card if amber mode 
# activated
TER_atoms = ["OXT", "Ca+", "CL"]
# the distance at which to assume atoms aren't bonded, and add a TER 
# card 
TER_cutoff = sys.maxint 
# resnames which represent an entire molecule of their own
TER_resnames = ["TIP","H2O","HOH","WAT", "K+", "Cl-", "Na+"] 
water_resnames = ("TIP","H2O","HOH","WAT")

protein_dict = {"ALA":"A", "ARG":"R", "ASN":"N", "ASP":"D", "ASPP":"D", 
                "CYS":"C", "GLN":"Q", "GLU":"E", "GLY":"G", "HSD":"H", 
                "HSE":"H", "HSP":"H", "ILE":"I", "LEU":"L", "LYS":"K", 
                "MET":"M", "PHE":"F", "PRO":"P", "SER":"S", "THR":"T", 
                "TRP":"W", "TYR":"Y", "VAL":"V", "CYX":"C", "HIE":"H", 
                "HID":"H", "HIP":"H", "HIS":"H", "CTER":"", "CT3":"", 
                "ACE":"", "GLUP":"E", "DISU":"", "LSN":"K"}
protein_backward_dict = {"I": "ILE", "Q": "GLN", "T": "THR", "G": "GLY", 
                         "H": "HIS", "W": "TRP", "E": "GLU", "C": "CYS", 
                         "D": "ASP", "S": "SER", "P": "PRO", "K": "LYS", 
                         "F": "PHE", "A": "ALA", "M": "MET", "L": "LEU", 
                         "R": "ARG", "V": "VAL", "N": "ASN", "Y": "TYR"}

class Atom():
  def __init__(self, record, index, name, altloc, resname, chain, resid, 
               icode, x, y, z, occupancy, beta, element, charge, rawline="", 
               radius="0.0"):
    # fill out atomic information
    self.record = record
    self.index = int(index)
    self.name = name.strip()
    self.altloc = altloc
    self.resname = resname.strip()
    self.chain = chain
    self.resid = resid
    self.icode = icode
    self.coords = [float(x), float(y), float(z)]
    self.x = float(x)
    self.y = float(y)
    self.z = float(z)
    self.occupancy = float(occupancy)
    self.beta = float(beta)
    self.element = element
    # then assign an element to this molecule
    if not self.element or self.element == ' ': 
      self.element = find_element(self.name)
    if charge:
      try:
        self.charge = float(charge)
      # then there is something weird with this value, and was 
      # obviously not meant to be a charge
      except ValueError:
        self.charge = charge
    else:
      self.charge = charge
    if radius:
      self.radius = float(radius)
    else:
      self.radius = radius
    #self.rawline = rawline
  def get_coords(self):
    return self.coords

  def to_dict(self):
    """ returns the attributes of the Atom() class in dictionary form"""
    our_dict = {}
    for var in ["record","index","name","altloc","resname","chain","resid",
                "icode","occupancy","beta","element","charge","radius"]:
      exec "our_dict['%s'] = self.%s" % (var,var)
    our_dict["x"] = self.coords[0]; our_dict["y"] = self.coords[1]; \
        our_dict["z"] = self.coords[2]
    return our_dict # return the dictionary

  def set_coords(self, coord):
    if type(coord) == matrix or type(coord) == array:
      coord = coord[0,0:3].tolist()[0]
    self.coords = coord
    return

  def print_pdbline(self, standard=True, space_separated_values=False):
    name = self.name
    # then pad it to left with a space
    if len(name) <= 3: name = "".join((" ",name)) 
    if standard:
      #formatline = "{0:<6.6}{1:>5.5} {2:<4.4}{3:1.1}{4:3.3} \
      #   {5:1.1}{6:>4.4}{7:1.1}   \
      #   {8:> 8.3f}{9:> 8.3f}{10:>8.3f}{11:>6.2f}{12:>6.2f} \
      #   {13:>2.2}{14:>2.2}\n" 
      #   charge was included here, but insufficient space
      #return formatline.format(self.record,str(self.index),name,self.altloc,
      #                         self.resname,self.chain,self.resid,self.icode,
      #                         self.coords[0],self.coords[1],self.coords[2],
      #                         self.occupancy,self.beta,self.element,
      #                         self.charge)
      formatline = "{0:<6.6}{1:>5.5} {2:<4.4}{3:1.1}{4:3.3} \
          {5:1.1}{6:>4.4}{7:1.1}   \
          {8:> 8.3f}{9:> 8.3f}{10:> 8.3f}{11:>6.2f}{12:>6.2f}          \
          {13:>2.2}  \n"
      return formatline.format(self.record,str(self.index),name,self.altloc,
                               self.resname,self.chain,self.resid,self.icode,
                               self.coords[0],self.coords[1],self.coords[2],
                               self.occupancy,self.beta,self.element,
                               self.charge)
    # then every value is only separated by a space
    elif space_separated_values: 
      #formatline = "{0} {1} {2} {3} {4} {5} {6} {7} {8:.3} {9:.3} {10:.3} \
      #   {11:.2} {12:.2} {13} {14}" 
      # charge was included here, but not included for standard mode, 
      # so I'm not including here either
      #return formatline.format(self.record,str(self.index),self.name,
      #                         self.altloc,self.resname,self.chain,
      #                         self.resid,self.icode,self.coords[0],
      #                         self.coords[1],self.coords[2],self.occupancy,
      #                         self.beta,self.element,self.charge)
      formatline = "{0} {1} {2} {3} {4} {5} {6} {7} {8:.3f} {9:.3f} \
          {10:.3f} {11:.2f} {12:.2f} {13}"
      ourline = formatline.format(self.record,str(self.index),self.name,
                                  self.altloc,self.resname,self.chain,
                                  self.resid,self.icode,self.coords[0],
                                  self.coords[1],self.coords[2],
                                  self.occupancy,self.beta,self.element)
      # remove extra spaces
      ourline = " ".join(ourline.split()) 
      return ourline
    # then print out a line that is close to standard at least for 
    # small PDBs, but can handle many more atoms/residues
    else: 
      # set it to atom by default, which gives us more room that HETATM
      self.record = "ATOM" 
      # all this gibberish just to get some decent spacing for the index
      record_index_spaces = len(self.record) + len(str(self.index)) 
      after_index_spaces = 1
      if record_index_spaces < 1:
        after_index_spaces = 0
        record_index_spaces = 1
      record_index_formatline = r"{0:}{1:}{2:}{3:}".format(
          self.record, " "*(11-record_index_spaces), 
          str(self.index), " "*after_index_spaces)
      # all this gibberish to get decent spacing for the resid column
      after_resid_spaces = 4 
      before_resid_spaces = 4 - len(str(self.resid))
      if before_resid_spaces < 0:
        after_resid_spaces = after_resid_spaces + before_resid_spaces
        before_resid_spaces = 0
      # then its a HUGE resid number
      if after_resid_spaces < 0:
        # forget about formatting 
        after_resid_spaces = 0 
      resid_formatline = r"{0:}{1:}{2:}".format(" "*before_resid_spaces, 
                                                self.resid, 
                                                " "*after_resid_spaces)
      #formatline = "{0}{1:<4.4}{2:1.1}{3:3.3} \
      #   {4:1.1}{5}{6:> 8.3f}{7:> 8.3f}{8:> 8.3f}{9:>6.2f}{10:>6.2f}  \
      #         {11:>2.2}{12:>2.2}\n"
      beta = "{0:4.2f}".format(self.beta)[:4]
      occupancy = "{0:4.2f}".format(self.occupancy)[:4]
      formatline = "{0}{1:<4.4}{2:1.1}{3:3.3} \
          {4:1.1}{5}{6:> 8.3f}{7:> 8.3f}{8:> 8.3f}  {9}  {10}          \
          {11:>2.2}{12:>2.2}\n"
      return formatline.format(record_index_formatline,name,self.altloc,
                               self.resname,self.chain,resid_formatline,
                               self.coords[0],self.coords[1],self.coords[2],
                               occupancy,beta,self.element,self.charge)

  def set_occupancy(self,occupancy):
    self.occupancy = occupancy

class Structure():
  def __init__(self, struct_id):
    self.struct_id = struct_id
    self.atoms = []
    self.num_atoms = 0
    self.num_resids = 0
    # a list of lists of atoms
    self.resids = [] 
    self.sequence = ""
    self.ter_list = []
    return

  def get_atoms(self):
    return self.atoms

  def save(self, filename, amber=False, standard=True, 
          space_separated_values=False, remark=True, endmdl=True, pqr=False, 
           pqrxml=False, nohydrogens=False):
    """Save this structure as a PDB or PQR file"""
    # perform some checks
    if standard:
      # then it will require 6 spaces
      if self.num_atoms > 99999: 
        raise Exception, "PDB file too big to write in standardized format. \
            Atom indeces exceed 5 digit maximum. Set 'standard' option to \
            False to enable large pdb file writing"
      # then it will require 5 spaces
      if self.num_resids > 9999: 
        raise Exception, "Too many residues to write in standardized format. \
            Residue indeces exceed 4 digit maximum. Set 'standard' option to \
            False to enable large pdb file writing"

    # write the file
    outfile = open(filename, "w")
    # because we don't want remarks added to pqrxml files
    if remark==True and pqrxml==False: 
      outfile.write(REMARK)
    if self.num_atoms > 0: oldcoord = self.atoms[0].coords
    #if self.num_resids > 9999: # then convert to hex
    #  self.resid_to_hex()
    if self.num_atoms > 0: oldresid = self.atoms[0].resid
    if pqrxml==True: outfile.write("<roottag>\n  <residue>\n    \
        <residue_name>%s</residue_name>\n    \
        <residue_number>%s</residue_number>\n" % (self.atoms[0].resname, 
                                                  self.atoms[0].resid))
    # for every atom in this structure                                              
    for atom in self.atoms: 
      # for TER cards before an atom
      if amber: 
        if (atom.resname in TER_resnames and atom.resid != oldresid):
          outfile.write("TER\n")
      if pqr==True:
        # join an endline to the end of the pqr line
        outfile.write(make_pqr_line(atom.to_dict())) 
      elif pqrxml==True:
        if oldresid != atom.resid:
          outfile.write("  </residue>\n  <residue>\n    \
              <residue_name>%s</residue_name>\n    \
              <residue_number>%s</residue_number>\n" % (atom.resname, 
                                                        atom.resid))
        outfile.write(make_pqrxml_line(atom.to_dict()))

      else: # then write a pdb file
        outfile.write(atom.print_pdbline(standard=standard, 
            space_separated_values=space_separated_values))
      # need to correctly place the TER cards after the current atom
      if amber: 
        coord_dist = array(atom.coords) - array(oldcoord)
        # print a TER card
        if atom.name in TER_atoms or numpy.linalg.norm(coord_dist) \
            > TER_cutoff : 
          outfile.write("TER\n")
      oldcoord = atom.coords
      oldresid = atom.resid
      #print atom.print_pdbline()
    if pqrxml: outfile.write("  </residue>\n</roottag>\n")
    if endmdl and not pqrxml:
      outfile.write("ENDMDL\n")
    outfile.close()

  def moveby(self, vector):
    """move all atoms by the vector"""
    vector = numpy.array(vector)
    #print vector
    for atom in self.atoms:
      atom.coords = list(vector + numpy.array(atom.coords))

  """def remove_atoms(self, indeces):
    'remove all atoms with given index from the structure. 
    indeces may be a list'
    pass"""

  def matrix_operation(self,op_matrix):
    """given a matrix, will apply matrix*vector operation on every atom
    """
    for atom in self.atoms:
      coords = numpy.hstack((matrix([atom.coords]),matrix([[1.0]])))
      newcoord = op_matrix * coords.T
      atom.coords = newcoord.T.tolist()[0][:3]


  def remove_res(self, resid):
    """remove all atoms with given resid from the structure. 
    resid may be a list"""
    # convert to a set if not already
    resids = set(resid) 
    index_counter = 0
    # just to keep track of all the resids 
    # given that are ACTUALLY in this pdb
    found_resids = set() 
    # for all atoms
    while index_counter < self.num_atoms: 
      if self.atoms[index_counter].resid in resids:
        self.atoms.pop(index_counter)
        self.num_atoms -= 1
        if self.num_atoms == 0: break
        found_resids.add(self.atoms[index_counter].resid)
        #resids.remove(self.atoms[index_counter].resid)
      else:
        # set the internal index numbers to be incremental
        self.atoms[index_counter].index = index_counter+1 
        index_counter += 1 # increment the index counter

    # reset the number of residues
    self.num_resids -= len(found_resids) 

  def renumber_indeces(self, start_at = 1):
    """renumbers the indeces within the pdb so that they are 
    consecutively numbered"""
    counter = start_at
    for atom in self.atoms:
      atom.index = counter
      counter += 1
    return

  def resid_to_hex(self):
    """converts all resids to hexadecimal values """
    for atom in self.atoms:
      resid = int(atom.resid)
      hex_str = hex(resid)
      newresid = "%4s" % hex_str[2:]
      atom.resid = newresid
      
  def get_sequence(self):
    """Reads this structure's atoms and residues to construct an 
    amino acid sequence"""
    oldresid = ""
    seq_list = []
    resid_list = []
    resid_sublist = []
    # loop thru the atoms
    for atom in self.atoms: 
      # we've hit the beginning of a new residue, so append to the list
      if atom.resid != oldresid: 
        seq_list.append(get_AA_code(atom.resname))
        if len(resid_sublist) > 0: resid_list.append(resid_sublist)
        resid_sublist = []
        oldresid = atom.resid
      resid_sublist.append(atom)
    if len(resid_sublist) > 0: resid_list.append(resid_sublist)
    self.sequence = "".join(seq_list)
    self.resids = resid_list
    return self.sequence
    
  
    
# this regular expression should satisfy the fields of nearly 
# any pdb file
# the original PDB parser regex
#pdbregex = re.compile(r'([A-Z]+) *([0-9]+) *([\S]+) +([\S]{3}) \
#     *([A-Z]{0,1}) *([0-9]+) *([-]{0,1}[0-9\.]+) *([- ][0-9\.]+) \
#     *([- ][0-9\.]+) *([- ][0-9\.]+) *([- ][0-9\.]+) *(.)?$') 
pdbregex = re.compile(r"^([A-Z]+) *([0-9a-f\*]+) *([\S]{1,4}) \
    *([ a-zA-Z]{1})([\S]{3,4}| [\S]{2}|  [\S]) +([@A-Z]{0,1}) \
    *([-0-9a-f]+)([a-zA-Z]{0,1}) *([- ]{0,1}[0-9]+\.[0-9]{3}) \
    *([- ]{0,1}[0-9]+\.[0-9]{3}) *([- ]{0,1}[0-9]+\.[0-9]{3}) \
    *([- ]{0,1}[0-9]+\.[0-9]{2}) *([- ]{0,1}[0-9]+\.[0-9]{2}) \
    *(\S{0,2}) *(\S{0,2}) *$")
    #pdbregex = re.compile(r'([A-Z]+) *([0-9a-f\*]+) *([\S]{1,4}) \
    #   *([ a-zA-Z]{1})([\S]{3}| [\S]{2}|  [\S]) +([A-Z]{0,1}) \
    #   *([-0-9]+)([a-zA-Z]{0,1}) *([- ][0-9\.]+) *([- ][0-9\.]+) \
    #   *([- ][0-9\.]+) *([- ][0-9]+\.[0-9]{2}) *([- ]{0,1}[\.0-9]+) \
    #   *(\S{0,2}) *(\S{0,2}) *$')
    #pdbregex = re.compile(r'([A-Z]+) *([0-9]+) *([\S]+) \
    #   *([a-zA-Z]{0,1}) *([\S]{3}) *([A-Z]{0,1}) \
    #   *([0-9]+)([a-zA-Z]{0,1}) *([- ][0-9\.]+) \
    #   *([- ][0-9\.]+) *([- ][0-9\.]+) *([- ][0-9\.]+) \
    #   *([- ][0-9\.]+) *(\S{0,2}) *(\S{0,2}) *$')
pqrregex = re.compile(r"^([A-Z]+) *([0-9a-f\*]+) *([\S]{1,4}) \
                      *([\S]{3,4}| [\S]{2}|  [\S]) +([@A-Z]{0,1}) \
                      *([-0-9a-f]+)([a-zA-Z]{0,1}) \
                      *([- ]{0,1}[0-9]+\.[0-9]{3}) \
                      *([- ]{0,1}[0-9]+\.[0-9]{3}) \
                      *([- ]{0,1}[0-9]+\.[0-9]{3}) \
                      *([- ]{0,1}[0-9]+\.[0-9]{1,4}) \
                      *([- ]{0,1}[0-9]+\.[0-9]{1,4}) \
                      *(\S{0,2}) *$")

def get_AA_code(amino3code, unknown="X"):
  """Given the 3-letter amino acid code, will return a letter 
  representing that amino acid. Unknown values are filled with the 
  'unknown' value."""
  if amino3code in protein_dict.keys():
    return protein_dict[amino3code]
  else:
    return unknown

class Big_PDBParser():
  def pdbparse(self, filename, preserve_index = False, preserve_resid = True, 
               pqr=False, conventional=False, multi_frame=False):
    """parses a PDB file and returns the line as a dict.
    Atom indeces automatically numbered. If preserve_index
    is set to True, then indeces from the file will be preserved
    """

    atoms = []
    ter_list = []
    # count each line of the file
    counter = 1 
    residcounter = 0
    oldresid = 0
    if multi_frame == True:
      pdb_struct_list = []
    # then we're passing a file or file-like object
    if type(filename) == file or type(filename) == type(StringIO()): 
      pdbfile = filename
    # otherwise, try to open it as a string
    elif type(filename) == str: 
      pdbfile = open(filename, "r")
    
    for pdbline in pdbfile:
      if pdbline.startswith("END"):
        if multi_frame == True:
          pdb_struct_list.append(atoms)
          # reset everything
          atoms = []; ter_list = []; counter = 1; 
          residcounter = 0; oldresid = 0 
        else:
          break
      if pdbline.startswith("TER"):
        ter_list.append(residcounter)
        # TODO: I don't like this cookie-cutter code, find a way 
        # to combine with "END" above
        #if multi_frame == True: 
        #  pdb_struct_list.append(atoms)
        # reset everything
        #  atoms = []; ter_list = []; counter = 1; residcounter = 0; 
        #  oldresid = 0 
        
      if not pdbline.startswith("ATOM") and not pdbline.startswith("HETATM"):
        continue
      pdbline = pdbline.strip()
      # then we are dealing with a pqr file
      if pqr: 
        if conventional:
          rawlinelist = self.conventional_parse(pdbline, pqr=True)
        else:
          rawlinelist = re.findall(pqrregex, pdbline)
        #assert conventional==False, "conventional parsing for \
        #   PQRs not yet implemented."

        if not rawlinelist:
          # then simply split on whitespace
          linelist = pdbline.split() 
          # then the chain is missing
          if len(linelist) == 9: 
            linelist.insert(3," ")
          linelist.insert(2,"")
          linelist.insert(6,"")

        try:
          linelist = rawlinelist[0]
          if len(linelist) == 10:
            linelist.insert(5,"")
            # then the chain is missing
          if len(linelist) == 11: 
            linelist.insert(4," ")

          if oldresid == "": oldresid = linelist[5]
          # increment the resid counter
          if linelist[5] != oldresid: 
            residcounter += 1

          if preserve_index:
            atomindex = linelist[1]
          else:
            atomindex = counter

          if preserve_resid:
            resid_index = linelist[5]
          else:
            resid_index = str(residcounter)

          #print "linelist:", linelist
          #exit()

          element=linelist[2][0]
          atom = Atom(record=linelist[0], index=atomindex, name=linelist[2], 
                      altloc="", resname=linelist[3], chain=linelist[4], 
                      resid=resid_index, icode=linelist[6], x=linelist[7], 
                      y=linelist[8], z=linelist[9], charge=linelist[10], 
                      radius=linelist[11], occupancy="1.0", beta="0.0", 
                      element=element)

        except IndexError:
          print "failure line: %s" % pdbline
          print "rawline: %s" % rawlinelist
          raise IndexError


      # then parse for a pdb file
      else: 
        # then we are parsing using conventional
        if conventional: 
          rawlinelist = self.conventional_parse(pdbline)
        else:
          rawlinelist = re.findall(pdbregex, pdbline)
          # fill the atom object
          if not rawlinelist:
            #print "error parsing line:\n", pdbline, rawlinelist
            #print "attempting to parse conventionally..."
            rawlinelist = self.conventional_parse(pdbline)
            # getting the first letter to be the element
            rawlinelist[0][13] = rawlinelist[0][2][0]
            # NOTE: line marked for removal upon completion of 
            # conventional parsing
            #print "ALERT: conventional parsing not yet implemented!" 
            #continue
        try:
          linelist = rawlinelist[0]
          if oldresid == "": oldresid = linelist[6]
          # increment the resid counter
          if linelist[6] != oldresid: 
            residcounter += 1
            oldresid = linelist[6]
            
          #print "linelist: ", linelist
          if preserve_index:
            atomindex = linelist[1]
          else:
            atomindex = counter
          if preserve_resid:
            resid_index = linelist[6]
          else:
            resid_index = str(residcounter)


          #if charge and not element: # then probabily it assigned the 
          # charge when it should have assigned the element
            # then there are alphabetical characters in
            #if re.match(): 
              #the charge when there should be numbers for charge 
              #   UNFINISHED...
          #, rawline=pdbline)
          atom = Atom(record=linelist[0], index=atomindex, name=linelist[2], 
                      altloc=linelist[3], resname=linelist[4], 
                      chain=linelist[5], resid=resid_index, icode=linelist[7], 
                      x=linelist[8], y=linelist[9], z=linelist[10], 
                      occupancy=linelist[11], beta=linelist[12], 
                      element=linelist[13], charge=linelist[14]) 


        except IndexError:
          print "failure line: %s" % pdbline
          print "rawline: %s" % rawlinelist
          raise IndexError

        #atom = Atom(record=linelist[0], index=linelist[1], 
        #            name=linelist[2], resname=linelist[3], 
        #            chain=linelist[4], resid=linelist[5], 
        #            x=linelist[6], y=linelist[7], z=linelist[8], 
        #            occupancy=linelist[9], beta=linelist[10], 
        #            atomtype=linelist[11])


      atoms.append(atom)
      
      counter += 1
      if type(filename) == str: pdbfile = open(filename, "r")
    
    if multi_frame:
      return pdb_struct_list, residcounter, ter_list
    else:
      return atoms, residcounter, ter_list
    #if pdbline.startswith != "ATOM" and pdbline
  # an emergency function that attempts to parse the line of a pdb file 
  # according to conventional rules
  def conventional_parse(self,line, pqr=False): 
    if pqr:
      # untested...
      conv_regex = re.compile(r"^(.{6})(.{5}).(.{4})(.{5}).(.{4})    \
          (.{8})(.{8})(.{8})(.{8})(.{7})*$") 
    else:
      conv_regex = re.compile(r"^(.{6})(.{5}).(.{4})(.)(.{4})(.)\
          (.{4})(.).{3}(.{8})(.{8})(.{8})(.{6})(.{6}).{0,10}(.{0,2})\
          (.{0,2}) *$")
    rawlinelist = re.findall(conv_regex,line)

    #print "rawlinelist:", map(string.strip, rawlinelist[0])
    if not rawlinelist:
      print "problem with line:", line
      # strip all the spaces off and return it
    return [map(string.strip, rawlinelist[0])] 

  def get_structure(self, struct_id, filename, preserve_index=False, 
                    preserve_resid=True, pqr=False, pqrxml=False, 
                    conventional=False, multi_frame=False):
    structure = Structure(struct_id)
    #structure.struct_id = struct_id
    # now parse the pdb file
    assert not (pqr == True and pqrxml == True), "both the 'pqr' and 'pqrxml' \
        options may not be set to 'True' at the same time."
    if pqrxml:
      pqrxml_generator = pqr_xml_parse(filename, preserve_resid=preserve_resid, 
                                       preserve_index=preserve_index)
      for atom_dict,num_res in pqrxml_generator:
        #print "atom_dict:", atom_dict
        atom = Atom(record="ATOM", index=atom_dict["index"], 
                    name=atom_dict["name"], altloc="", 
                    resname=atom_dict["resname"], chain="", 
                    resid=atom_dict["resid"], icode="", 
                    x=atom_dict["x"], y=atom_dict["y"], 
                    z=atom_dict["z"], element=atom_dict["name"][0], 
                    charge=atom_dict["charge"], radius=atom_dict["radius"], 
                    occupancy="1.0", beta="0.0", )
        structure.atoms.append(atom)
      structure.num_resids = num_res
      return structure
    else:
      #structure.atoms, structure.num_resids, structure.sequence, \
      #   structure.resids = self.pdbparse(filename,preserve_index,
      #                                    preserve_resid,pqr=pqr,
      #                                    conventional=conventional)
      if multi_frame == True:
        structure_list = []
        atoms_list, num_resids, ter_list = self.pdbparse(
            filename,preserve_index,preserve_resid,pqr=pqr, 
            conventional=conventional,multi_frame=True)
        print "ter_list:", ter_list
        print "len(atoms_list):", len(atoms_list)
        print "num_resids:", num_resids
        for atoms in atoms_list:
          structure = Structure(struct_id)
          structure.atoms, structure.num_resids, structure.ter_list = \
              atoms, num_resids, ter_list
          structure.num_atoms = len(structure.atoms)
          structure_list.append(structure)
        return structure_list
      else:
        structure.atoms, structure.num_resids, structure.ter_list = \
            self.pdbparse(filename,preserve_index,preserve_resid,pqr=pqr,
                          conventional=conventional,multi_frame=False)
        structure.num_atoms = len(structure.atoms)
      #NOTE: There is no way so far to assign structure.num_resids
      return structure

parser=Big_PDBParser()
#parses a pqrxml file from BrownDye
def pqr_xml_parse(filename, preserve_resid = True, preserve_index=False): 
  # I have to code this carefully because I want it to be able to 
  # handle very large structures
  resid_counter = 1
  index_counter = 1

  # get an iterable
  context = iterparse(filename, events=("start", "end"))
  # turn it into an iterator
  context = iter(context) 
  event, root = context.next()
  for event, elem in iterparse(filename):
    if event == "end":
      # residue info
      if elem.tag == "residue_name": resname = elem.text
      if preserve_resid and elem.tag == "residue_number": 
        resid = int(elem.text)
      # atom info
      if elem.tag == "atom_name": atom_name = elem.text
      if preserve_index and elem.tag == "atom_number": 
        index = int(elem.text)
      if elem.tag == "x": x = float(elem.text)
      if elem.tag == "y": y = float(elem.text)
      if elem.tag == "z": z = float(elem.text)
      if elem.tag == "charge": charge = float(elem.text)
      if elem.tag == "radius": radius = float(elem.text)
      if elem.tag == "atom": # ending the atom
        if not preserve_index:
          index = index_counter
        index_counter += 1
        line_dict = {"index":index, "name":atom_name, "resname":resname, 
                     "resid":resid, "x":x,"y":y,"z":z, "charge":charge, 
                     "radius":radius,}
        #print make_pqr_line(line_dict)
        yield line_dict, resid_counter
        elem.clear
      # ending the residue
      if elem.tag == "residue": 
        if not preserve_resid:
          resid = resid_counter
        resid_counter += 1
        elem.clear()
        # clear all previous entries in the root to save space
        root.clear() 

    elem.clear()
  """
  root = tree.getroot()
  for residue in root:
    resname = residue.find('residue_name')
    resid = residue.find('residue_number')
    atoms = residue.findall('atom')
    for atom in atoms:
      atom_name = atom.find('atom_name')
      serial = atom.find('atom_number')
      x = atom.find('x')
      y = atom.find('y')
      z = atom.find('z')
      charge = atom.find('charge')
      radius = atom.find('radius')
      '''

def loadpdb(filename):
  "quick and convenient way to load a pdb file"
  newpdb=parser.get_structure('quickload', filename, 
                              preserve_resid=False )
  return newpdb

def loadpqr(filename,preserve_resid=False):
  "quick and convenient way to load a pqr file"
  newpqr=parser.get_structure('quickload', filename, pqr=True, 
                              preserve_resid=preserve_resid )
  return newpqr

def isfloat(number):
  if type(number) in [float, numpy.float64, numpy.float32]:
    return True
  else:
    return False

def make_pqr_line(user_line_dict, chain=False):
  '''creates a pqr line based on the specified parameters in line_dict
  '''
  line_dict = {'record':'ATOM', 'index':'0', 'name':'---', 'altloc':'', 
               'resname':'---', 'chain':'', 'resid':'0', 'icode':'', 
               'x':'0.000','y':'0.000','z':'0.000', 'charge':'0.0000', 
               'radius':'0.0000',}
  line_dict.update(user_line_dict)
  # if the value is a float, then convert to a string with the proper 
  # precision and width
  if isfloat(line_dict['x']): line_dict['x'] = "% 8.3f" % line_dict['x'] 
  # if the value is a float, then convert to a string with the proper 
  # precision and width
  if isfloat(line_dict['y']): line_dict['y'] = "% 8.3f" % line_dict['y'] 
  # if the value is a float, then convert to a string with the proper 
  # precision and width
  if isfloat(line_dict['z']): line_dict['z'] = "% 8.3f" % line_dict['z'] 
  if isfloat(line_dict['charge']): 
    line_dict['charge'] = "%0 6.4f" % line_dict['charge']
  if isfloat(line_dict['radius']): 
    line_dict['radius'] = "%0 6.4f" % line_dict['radius']
  for key in line_dict.keys():
    # convert every value in the dictionary into a string 
    # for easy formatting
    line_dict[key] = str(line_dict[key]) 
  if chain: # then write the chainID
    formatline = "{record:<6.6}{index:>5.10} {name:^4.4} \
        {resname:<4.4}{chain:1.1}{resid:>4.9}    \
        {x:>8.8}{y:>8.8}{z:>8.8} {charge:>7.7} {radius:>6.6}\n"
  else:
    formatline = "{record:<6.6}{index:>5.10} {name:^4.4} \
    {resname:<4.4} {resid:>4.9}    {x:>8.8}{y:>8.8}{z:>8.8} \
    {charge:>7.7} {radius:>6.6}\n"
  # automatically populates the line with values from line_dict
  formatstring = formatline.format(**line_dict) 
  return formatstring

  #return formatline.format(self.record,str(self.index),name,
  #                         self.altloc,self.resname,self.chain,
  #                         self.resid,self.icode,self.coords[0],
  #                         self.coords[1],self.coords[2],
  #                         self.occupancy,self.beta,self.element,
  #                         self.charge)



def make_pqrxml_line(user_line_dict):
  '''creates a pqr line based on the specified parameters in line_dict
  '''
  line_dict = {'record':'ATOM', 'index':'0', 'name':'---', 'altloc':'', 
               'resname':'---', 'chain':'', 'resid':'0', 'icode':'', 
               'x':'0.000','y':'0.000','z':'0.000', 'charge':'0.0000', 
               'radius':'0.0000',}
  line_dict.update(user_line_dict)
  # if the value is a float, then convert to a string with the proper 
  # precision and width
  if isfloat(line_dict['x']): line_dict['x'] = "%.6f" % line_dict['x'] 
  # if the value is a float, then convert to a string with the proper 
  # precision and width
  if isfloat(line_dict['y']): line_dict['y'] = "%.6f" % line_dict['y'] 
  # if the value is a float, then convert to a string with the proper 
  # precision and width
  if isfloat(line_dict['z']): line_dict['z'] = "%.6f" % line_dict['z'] 
  if isfloat(line_dict['charge']): line_dict['charge'] = \
    "%.6f" % line_dict['charge']
  if isfloat(line_dict['radius']): line_dict['radius'] = \
    "%.6f" % line_dict['radius']
  for key in line_dict.keys():
    # convert every value in the dictionary into a string for easy 
    # formatting
    line_dict[key] = str(line_dict[key]) 

  #formatline = "{record:<6.6}{index:>5.5} {name:^4.4}{altloc:1.1}\
  #   {resname:3.3} {chain:1.1}{resid:>4.4}{icode:1.1}   \
  #   {x:>8.8}{y:>8.8}{z:>8.8} {charge:>7.7}{radius:>7.7}\n"
  formatline = '''    <atom>
      <atom_name>{name}</atom_name>
      <atom_number>{index}</atom_number>
      <x>{x}</x>
      <y>{y}</y>
      <z>{z}</z>
      <charge>{charge}</charge>
      <radius>{radius}</radius>
    </atom>\n'''
  # automatically populates the line with values from line_dict
  formatstring = formatline.format(**line_dict) 
  return formatstring

def find_element(name):
  '''find the most likely element of an atom given the atomic name'''
  # keeps only the letters in the 'name' string
  letters = re.sub("[^a-zA-Z]*", "", name) 
  # then we should have a weight for this entry
  if letters in atomic_weights.keys(): 
    return letters
  # then its a named atom and we can take the first letter, 
  # which should be the proper name
  elif letters[0] in atomic_weights.keys(): 
    return letters[0]
  else:
    return ''


def avg(numlist):
  'finds the average of a list of numbers'
  oursum = sum(numlist)
  return oursum / float(len(numlist))

def getcoords(structure):
  'returns a list of coordinates from all of the atoms'
  coords = []
  atomlist = structure.get_atoms()
  for atom in atomlist:
    coords.append(atom.get_coords())
  return coords

def rmsd(structure1, structure2):
  '''returns the rmsd between two structures with the same number of 
  atoms.'''
  coords1 = getcoords(structure1)
  coords2 = getcoords(structure2)
  assert len(coords1) == len(coords2), "RMSD can only be found between \
      structures with the same number of atoms."
  total_square_deviation = 0.0
  n = len(coords1)
  for i in range(n):
    coord1 = coords1[i]
    coord2 = coords2[i]
    for j in [0, 1, 2]:
      total_square_deviation += (coord1[j] - coord2[j]) ** 2
  root_mean_square_deviation = numpy.sqrt(total_square_deviation / n)
  return root_mean_square_deviation

def minmax_width (structure, water_only=True, 
                  wat_resnames=water_resnames):
  '''returns the width of the minimum and maximum coordinate values 
  in the x,y,z direction'''
  coords = getcoords(structure)
  xlist = []
  ylist = []
  zlist = []
  i=0
  for coord in coords:
    if water_only and wat_resnames and structure.atoms[i].resname \
        not in wat_resnames:
      i+=1
      continue
    xlist.append(coord[0])
    ylist.append(coord[1])
    zlist.append(coord[2])
    i+=1

  return ( max(xlist)-min(xlist), max(ylist)-min(ylist), \
      max(zlist)-min(zlist))

def center (structure):
  '''returns the center of a pdb'''
  coords = getcoords(structure)
  xlist = []
  ylist = []
  zlist = []

  for coord in coords:
    xlist.append(coord[0])
    ylist.append(coord[1])
    zlist.append(coord[2])

  return ((max(xlist) + min(xlist))*0.5, (max(ylist) + min(ylist))*0.5,\
       (max(zlist) + min(zlist)) * 0.5)

def center_of_mass (structure, weighted=True, heavy_atoms=False):
  '''finds the center of mass of a structure. Returns a numpy vector'''
  # keeps track of the weight of the molecule
  total_weight = 0.0 
  # keeps track of the sum of the coordinates
  coord_sum = numpy.array([0.0,0.0,0.0]) 
  # for every atom in the structure
  for atom in structure.get_atoms(): 
    # we don't care about the hydrogens, so skip them
    if heavy_atoms==True and atom.element=='H': continue 
    if weighted:
      atom_weight = atomic_weights[atom.element]
    else:
      atom_weight = 1.0 # they are all given the same weight
    #print atom_weight
    total_weight += atom_weight # increment the total_weight
    coord = numpy.array(atom.get_coords())
    weighted_coord = coord * atom_weight
    coord_sum += weighted_coord # add the weighted coordinate
  #print total_weight
  return coord_sum / total_weight # divide by the total weight

def moments_of_inertia(structure, weighted=True):
  '''finds the inertia tensor for all atoms in the structure. 
  Returns as a 3x3 numpy array'''
  com=center_of_mass(structure,weighted)
  #translate to the origin
  structure.moveby(-com)
  # these are the elements of our tensor
  Ixx = 0.0; Ixy = 0.0; Ixz = 0.0; Iyy = 0.0; Iyz = 0.0; Izz = 0.0
  for atom in structure.get_atoms():
    if weighted:
      atom_weight = atomic_weights[atom.element]
    else:
      atom_weight = 1.0 # they are all given the same weight
    x = atom.coords[0]
    y = atom.coords[1]
    z = atom.coords[2]
    Ixx = Ixx + atom_weight*(y*y + z*z)
    Ixy = Ixy - atom_weight*(x*y)
    Ixz = Ixz - atom_weight*(x*z)
    Iyy = Iyy + atom_weight*(x*x + z*z)
    Iyz = Iyz - atom_weight*(y*z)
    Izz = Izz + atom_weight*(x*x + y*y)
  # once the loop is complete, assemble the tensor matrix
  I = numpy.array([[Ixx, Ixy, Ixz],
                   [Ixy, Iyy, Iyz],
                   [Ixz, Iyz, Izz]])
  structure.moveby(com)
  return(I)

def principal_axes(structure, weighted=True):
  '''finds the principal axes of a structure'''
  I = moments_of_inertia(structure,weighted)
  evals, evecs = numpy.linalg.eig(I) # calculated the Inertia tensor
  # sort the eigenvectors by their eigenvalues
  idx = evals.argsort()[::-1]
  evals = evals[idx]
  evecs = evecs[:,idx]
  crs = normalize_vector(numpy.cross(evecs[:,0], evecs[:,1]))
  if not numpy.allclose(crs, evecs[:,2]):
    evecs[:,2] = -evecs[:,2]
  evecs = evecs.T # better to get the transpose
  return evals, evecs


def molecular_radius(structure):
  '''finds the distance of the structure center of mass to the furthest 
  atom'''
  com = center_of_mass(structure)
  largest_radius = 0.0
  for atom in structure.get_atoms(): # for every atom in the structure
    if atom.radius == '0.0':
      atom_radius = radii[atom.element]
    else:
      atom_radius = atom.radius
    radius = numpy.linalg.norm(numpy.array(atom.coords) \
        - numpy.array(com)) + float(atom_radius)
    if radius > largest_radius: largest_radius = radius
  return largest_radius

def regurge(infile,outfile):
  '''reads a pdbfile and attempts to rewrite it back out exactly the 
  same way'''
  structure=parser.get_structure('regurge', infile, 
                                 preserve_index = False)
  structure.save(outfile, standard=False)

def load_pdb_traj(infilename):
  '''reads a pdb trajectory separated by ENDMDL lines and returns a 
list of structures'''
  # Warning: This function is currently SLOW! Try to use MDAnalysis
  traj =[]
  starttime = time.time()
  # a file-like object to hold the current pdb file to be opened 
  # later by the pdb parser
  pdbtemp = StringIO() 
  infile = open(infilename,'r')
  counter = 0
  # read every line in the file
  for line in infile.xreadlines(): 
    pdbtemp.write(line)
    # then we have ended a frame of the pdb trajectory
    if line.startswith("ENDMDL"): 
      pdbtemp.seek(0) # reset to the beginning of the file
      curstruct = parser.get_structure('traj_frame%d' % counter, 
                                       pdbtemp, preserve_index = False)
      traj.append(curstruct)
      pdbtemp = StringIO()
    counter += 1
  curstruct = parser.get_structure('traj_frame%d' % counter, pdbtemp, 
                                   preserve_index = False)
  # this is to help prevent a frame containing nothing from being 
  # written
  if curstruct.num_atoms > 0: 
    traj.append(curstruct)
  pdbtemp.close()
  print "time elapsed:", time.time() - starttime
  return traj

def pdb_from_MDAnalysis(MDatomselection):
  '''given an MD atomselection object, this function will return a pdb 
  file object'''
  # create a new structure object
  newstruct = Structure("From MD Analysis") 
  # for every atom in this selection
  for atom in MDatomselection.atoms: 
    newatom = Atom(record='ATOM', index=atom.number, name=atom.name, 
                   altloc='', resname=atom.resname, chain='X', 
                   resid=atom.resid, icode='', x=atom.pos[0], 
                   y=atom.pos[1], z=atom.pos[2], occupancy=0.0, 
                   beta=0.0, element=find_element(atom.name), 
                   charge=atom.charge)
    newstruct.atoms.append(atom)
  newstruct.num_atoms = len(MDatomselection.atoms)
  return newstruct

'''def pdb_from_MDAnalysis_alt(MDatomselection):
  # TOO SLOW
  MDatomselection.write('/tmp/temp_md.pdb', format="PDB")
  newstruct = parser.get_structure('From MD Analysis', 
                                   '/tmp/temp_md.pdb')
  return newstruct'''

def test2methods(n,MDatomselection):
  starttime = time.time()
  for i in range(n):
    something = pdb_from_MDAnalysis(MDatomselection)
  endtime = time.time()
  print "method 1 time:", endtime - starttime

  starttime = time.time()
  for i in range(n):
    something = pdb_from_MDAnalysis_alt(MDatomselection)
  endtime = time.time()
  print "method 2 time:", endtime - starttime

def ligmerge(ligand, receptor, remove_water=True, hard_limit=3.0, 
             verbose=True):
  '''given a ligand structure and a receptor structure, will merge the 
  two to create a single structure. if remove_water is True, will remove
  all water molecules clashing with the ligand within the hard_limit'''
  removing_atoms = ["HOH", "H2O", "WAT", "Cl-", "Na+", "K+"]
  new_receptor = deepcopy(receptor)
  lig_com = center_of_mass(ligand)
  if verbose: print "lig_com:", lig_com
  lig_rad = molecular_radius(ligand)
  # all receptor atoms close to the ligand
  within_lig_proximity = [] 
  # loop thru the receptor atoms
  for recatom in range(receptor.num_atoms): 
    recatom_coords = numpy.array(receptor.atoms[recatom].coords)
    dist = numpy.linalg.norm(recatom_coords - lig_com)
    # if the rec atom is within the molecular radius of the 
    # ligand center
    if dist < lig_rad + hard_limit: 
      # append the atom index
      within_lig_proximity.append(receptor.atoms[recatom]) 
  # now we have all the indeces of any water molecule that could 
  # possibly be clashing, find the ones who are actually clashing
  clashing_waters = []
  resids_to_remove = []
  for prox_atom in within_lig_proximity:
    for lig_atom in ligand.get_atoms():
      lig_coords = numpy.array(lig_atom.coords)
      rec_coords = numpy.array(prox_atom.coords)
      #if prox_atom.resid == 5883 and verbose: print "found resid 5883"
      # then its clashing
      if numpy.linalg.norm(rec_coords - lig_coords) < hard_limit:
        #print "clashing", numpy.linalg.norm(rec_coords - lig_coords), 
        #                                    rec_coords, lig_coords
        # then mark the waters for removal
        if prox_atom.resname in removing_atoms: 
          # ...but only if its an oxygen
          if prox_atom.element == "H": 
            # ignore clashing hydrogens
            pass  
          # then its presumably a hydrogen
          else: 
            # NOTE: method does not exist yet
            resids_to_remove.append(prox_atom.resid) 
        else: # then something else is clashing
          if verbose: 
            print "Alert: non-H2O atom clashing with ligand: id:%d \
                resname:%s resid: %s" % (prox_atom.index, 
                                         prox_atom.resname, 
                                         prox_atom.resid)
      else:
        pass
        #print "not clashing", numpy.linalg.norm(rec_coords \
        #   - lig_coords), rec_coords, lig_coords
  new_receptor.remove_res(resids_to_remove)
  # now create a new structure, appending non-waters first
  new_holo = Structure('holo')
  hit_water_1 = False
  hit_water_2 = False
  counter1 = 0
  counter2 = 0
  oldresid = ''
  # loop through until we hit water or ions
  if new_receptor.num_atoms == 0: return new_holo, 0
  while hit_water_1 == False:
    curresname = new_receptor.atoms[counter1].resname
    if curresname in removing_atoms:
      hit_water_1 = True
      break
    new_holo.atoms.append(deepcopy(new_receptor.atoms[counter1]))
    new_holo.num_atoms += 1
    if new_receptor.atoms[counter1].resid != oldresid:
      new_holo.num_resids += 1
      oldresid = new_receptor.atoms[counter1].resid
    counter1 += 1
    if counter1 >= new_receptor.num_atoms:
      break
  # the last index of the receptor where the ligand was added
  inserted_index = counter1 
  # we've added all protein atoms from the receptor, now add ligand
  oldresid = ''
  for counter2 in range(ligand.num_atoms):
    new_holo.atoms.append(deepcopy(ligand.atoms[counter2]))
    new_holo.num_resids += 1
    if ligand.atoms[counter2].resid != oldresid:
      new_holo.num_resids += 1
      oldresid = ligand.atoms[counter2].resid
  last_ligand_index = counter2
  # all ligand atoms are added, now add the rest of the water 
  # molecules from receptor
  oldresid = ''
  for counter1 in range(counter1, new_receptor.num_atoms):
    new_holo.atoms.append(deepcopy(new_receptor.atoms[counter1]))
    new_holo.num_atoms += 1
    if new_receptor.atoms[counter1].resid != oldresid:
      new_holo.num_resids += 1
      oldresid = new_receptor.atoms[counter1].resid

  # all atoms now added to new structure in proper order
  return new_holo, inserted_index, last_ligand_index

def normalize_vector(array, axis=-1):
  '''
  Normalize the vectors of A in the direction of axis. This means 
  that each vector will have length 1. The default axis is the last.

  Arguments:

      - array (``numpy.ndarray``) A numpy array.
      - axis (``int``) The axis which will have vectors of lenght 1.
  '''
  shape = list(array.shape)
  shape[axis] = 1
  length = numpy.sqrt((array*array).sum(axis))
  out = array / length.reshape(shape)
  return out

class Test_pdb_functions(unittest.TestCase):
  # several test cases to ensure the functions in this module 
  # are working properly
  # this function runs first, it's like an initialization
  #def aaa(self): 
  #  print "initializing..."


  def test_main(self):
    #print "WARNING: pdb2.py does not have comprehensive unittests"
    return


  def test_Atom_class(self): # unit test for the Atom class
    # first test __init__()
    testatom = Atom(record="ATOM", index="150", name="CA", altloc='', 
                    resname="ALA", chain="X", resid="15", icode='', 
                    x='123.456', y='234.567', z='345.678', 
                    occupancy="1.00", beta='0.50', element='C', 
                    charge='0.30')
    self.assertEqual(testatom.record, "ATOM"); 
    self.assertEqual(testatom.index, 150); 
    self.assertEqual(testatom.name, "CA"); 
    self.assertEqual(testatom.resname, "ALA"); 
    self.assertEqual(testatom.chain, "X")
    self.assertEqual(testatom.resid, "15"); 
    self.assertEqual(testatom.coords, [123.456,234.567,345.678]); 
    self.assertEqual(testatom.occupancy, 1.0); 
    self.assertEqual(testatom.beta, 0.5)
    self.assertEqual(testatom.element, 'C'); 
    self.assertEqual(testatom.charge, 0.3);
    # test get_coords()
    self.assertEqual(testatom.get_coords(), [123.456,234.567,345.678])
    # test to_dict()
    testdict = testatom.to_dict()
    atomdict = {'record':"ATOM", 'index':150, 'name':"CA", 'altloc':'', 
                'resname':"ALA", 'chain':"X", 'resid':"15", 'icode':'', 
                'x':123.456, 'y':234.567, 'z':345.678, 'occupancy':1.0, 
                'beta':0.5, 'element':'C', 'charge':0.30,'radius':0.0}
    self.assertEqual(testatom.to_dict(), atomdict)
    # test write_pdbline()
    # standard
    result = testatom.print_pdbline(standard=True, 
                                    space_separated_values=False)
    expected_result = "ATOM    150  CA  ALA X  15     \
        123.456 234.567 345.678  1.00  0.50           C  \n"
    # standard mode
    self.assertEqual(result, expected_result) 
    # space separated values
    result = testatom.print_pdbline(standard=False, 
                                    space_separated_values=True)
    expected_result = "ATOM 150 CA ALA X 15 123.456 234.567 \
        345.678 1.00 0.50 C"
    # space separated mode
    self.assertEqual(result, expected_result) 
    # test set_coords()
    testatom.set_coords([987.654, 876.543, 765.432])
    self.assertEqual(testatom.coords, [987.654, 876.543, 765.432])

  # unit test for the Structure class 
  def test_Structure_class(self): 
    # first test __init__()
    empty = Structure('unit test empty')


  # this simultaneously tests many other functions in the parser
  def test_loadpdb(self): 
    self.assertEqual(test_struct1_pdb.num_atoms, 
                    len(test_struct1_pdb.atoms))
    self.assertEqual(test_struct1_pdb.num_resids, 3)
    self.assertEqual(test_struct1_pdb.num_atoms, 22)
    self.assertEqual(test_struct2_pdb.num_atoms, 
                    len(test_struct2_pdb.atoms))
    self.assertEqual(test_struct2_pdb.num_resids, 8519)
    self.assertEqual(test_struct2_pdb.num_atoms, 26565)
    self.assertEqual(test_struct3_pdb.num_atoms, 
                     len(test_struct3_pdb.atoms))
    self.assertEqual(test_struct3_pdb.num_resids, 1544)
    self.assertEqual(test_struct3_pdb.num_atoms, 23004)

  def test_pdb_parse(self):
    test_pdb_line = "ATOM      1  N   MET X   0    -304.463-303.390 \
        111.670  0.00  0.00            "
    test1_list = [['ATOM', '1', 'N', '', 'MET', 'X', '0', '', 
                   '-304.463', '-303.390','111.670', '0.00', '0.00', 
                   '', '']]
    test_pqr_line = "ATOM      1    N MET     0    -304.463-303.390 \
        111.670 -0.3000 1.8000"
    test2_list = [['ATOM', '1', 'N', 'MET', '0', '-304.463','-303.390',
                   '111.670', '-0.3000', '1.8000']]
    problem_line =  "ATOM      1  N   VAL     1      -1.552  16.438 \
        -23.987  0.0577 1.8240"
    test3_list = [['ATOM', '1', 'N', 'VAL', '1', '-1.552','16.438',
                   '-23.987', '0.0577', '1.8240']]
    pdb_line = parser.conventional_parse(test_pdb_line,pqr=False)
    self.assertEqual(pdb_line, test1_list)
    pqr_line = parser.conventional_parse(test_pqr_line,pqr=True)
    self.assertEqual(pqr_line, test2_list)
    pqr_line = parser.conventional_parse(problem_line,pqr=True)
    self.assertEqual(pqr_line, test3_list)

  def test_pdbparse_pqr(self):
    problem_line = "ATOM      1   N  VAL     1      -1.552  16.438 \
        -23.987  0.0577 1.8240"
    test_list = [['ATOM', '1', 'N', 'VAL', '1', '-1.552','16.438',
                  '-23.987', '0.0577', '1.8240']]
    pqr_line = parser.conventional_parse(problem_line,pqr=True)
    self.assertEqual(pqr_line, test_list)


  def test_make_pqr_line(self):
    test_pqr_line = "ATOM      1  N   MET     0    -304.463-303.390 \
        111.670 -0.3000  1.800\n"
    test_line_dict1 = {'index':1, 'name':'N', 'resname':'MET', 
                       'resid':'0', 'x':-304.463, 'y':-303.390, 
                       'z':111.670, 'radius':1.8000, 'charge':-0.3000}
    test_line_dict2 = {'index':'1', 'name':'N', 'resname':'MET', 
                       'resid':'0', 'x':'-304.463', 'y':'-303.390', 
                       'z':'111.670', 'radius':'1.800', 
                       'charge':'-0.3000'}
    result = make_pqr_line(test_line_dict1, chain=False)
    self.assertEqual(test_pqr_line, result)
    result = make_pqr_line(test_line_dict2, chain=False)
    self.assertEqual(test_pqr_line, result)

  def test_make_pqrxml_line(self):
    test_pqr_line = formatline = '''    <atom>
      <atom_name>N</atom_name>
      <atom_number>1</atom_number>
      <x>-304.463000</x>
      <y>-303.390000</y>
      <z>111.670000</z>
      <charge>-0.300000</charge>
      <radius>1.800000</radius>
    </atom>\n'''
    test_line_dict1 = {'index':1, 'name':'N', 'resname':'MET', 
                       'resid':'0', 'x':-304.463, 'y':-303.390, 
                       'z':111.670, 'radius':1.8000, 'charge':-0.3000}
    test_line_dict2 = {'index':'1', 'name':'N', 'resname':'MET', 
                       'resid':'0', 'x':'-304.463000', 
                       'y':'-303.390000', 'z':'111.670000', 
                       'radius':'1.800000', 'charge':'-0.300000'}
    result = make_pqrxml_line(test_line_dict1)
    self.assertEqual(test_pqr_line, result)
    result = make_pqrxml_line(test_line_dict2)
    self.assertEqual(test_pqr_line, result)

  # just a small test to make sure that the function 
  # calls without an error
  def test_find_element(self): 
    # alpha carbon
    self.assertEqual(find_element('CA'), 'C') 
  # just a small test to make sure that the function calls without an 
  # error
  def test_avg(self): 
    test_list = [20,60,70]
    test_avg = 50
    self.assertEqual(avg(test_list), test_avg)
  # just a small test to make sure that the function calls without an 
  # error
  def test_get_coords(self): 
    getcoords(test_struct1_pdb)

  def test_minmax_width(self):
    minmax_list = minmax_width(test_struct1_pdb, water_only=False)
    expected = (5.2510000467300415,7.6479997634887695,3.021000027656555)
    for i in range(len(expected)):
      self.assertAlmostEqual(minmax_list[i], expected[i], places=3)

  def test_center(self):
    center_list = center(test_struct1_pdb)
    expected = (4.1114999651908875, 4.823999881744385, 
                -0.6205000281333923)
    for i in range(len(expected)):
      self.assertAlmostEqual(center_list[i], expected[i], places=3)

  def test_center_of_mass(self):
    center_list = center_of_mass(test_struct1_pdb, weighted = False)
    # center of mass
    expected = (4.4929094314575195, 4.853545665740967, 
                -0.22363637387752533) 
    for i in range(len(expected)):
      self.assertAlmostEqual(center_list[i], expected[i], places=3)
  # just a small test to make sure that the function calls without an 
  # error
  def test_moments_of_inertia(self): 
    moments_of_inertia(test_struct1_pdb)
  # just a small test to make sure that the function calls without an 
  # error
  def test_principal_axes(self): 
    principal_axes(test_struct1_pdb)
  # just a small test to make sure that the function calls without an 
  # error
  def test_molecular_radius(self): 
    molecular_radius(test_struct1_pdb)
  # just a small test to make sure that the function calls without an 
  # error
  def test_regurge(self): 
    regurge(test_struct1_pdb_filename,'/tmp/test.pdb')

  def test_load_pdb_traj(self):
    pass # not testing this function

  def test_pdb_from_MDAnalysis(self):
    pass # not testing this function

  def test_ligmerge(self):
    pass # not testing this function

  def test_normalize_vector(self):
    vec = numpy.array([1.0, 2.0, 3.0])
    normed = numpy.array([0.2672612419124244, 0.5345224838248488, 
                          0.8017837257372732])
    self.assertEqual(normalize_vector(vec).all(), normed.all())


if __name__=="__main__":
  print "Now running unit tests for pdb2.py"
  # an alanine dipeptide
  test_struct1_pdb_filename = 'pdb2_test/adi_dry.pdb' 
  # troponin C solvated in H2O
  test_struct2_pdb_filename = 'pdb2_test/tropc_wet.pdb' 
  test_struct3_pdb_filename = 'pdb2_test/cal-2hty-tetra.pdb'
  test_struct1_pqr_filename = 'pdb2_test/tami.pqr'
  test_struct2_pqr_filename = 'pdb2_test/tropc_dry.pqr'
  test_struct3_pqr_filename = 'pdb2_test/cal-2hty-tetra.pqr'
  test_struct1_pqrxml_filename = 'pdb2_test/tami.pqrxml'
  test_struct1_pdb = loadpdb(test_struct1_pdb_filename)
  test_struct2_pdb = loadpdb(test_struct2_pdb_filename)
  test_struct3_pdb = loadpdb(test_struct3_pdb_filename)
  test_struct1_pqr = loadpqr(test_struct1_pqr_filename)
  test_struct2_pqr = loadpqr(test_struct2_pqr_filename)
  test_struct3_pqr = loadpqr(test_struct3_pqr_filename)
  unittest.main() # then run unit tests
